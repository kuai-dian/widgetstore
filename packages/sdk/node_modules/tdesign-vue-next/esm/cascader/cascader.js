/**
 * tdesign v0.8.0
 * (c) 2022 tdesign
 * @license MIT
 */

import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { defineComponent, Transition, createVNode, mergeProps, resolveComponent } from 'vue';
import isEmpty from 'lodash/isEmpty';
import isEqual from 'lodash/isEqual';
import { prefix } from '../config.js';
import { TreeStore } from '../_common/js/tree/tree-store.js';
import { emitEvent } from '../utils/event.js';
import { getPropsApiByEvent } from '../utils/helper.js';
import { getValue, getTreeValue } from './utils/helper.js';
import { treeNodesEffect, treeStoreExpendEffect } from './utils/cascader.js';
import Panel from './components/Panel.js';
import { Popup } from '../popup/index.js';
import InputContent from './components/InputContent.js';
import { EVENT_NAME_WITH_KEBAB } from './interface.js';
import props from './props.js';
import '@babel/runtime/helpers/classCallCheck';
import '@babel/runtime/helpers/createClass';
import 'lodash/difference';
import 'lodash/camelCase';
import 'lodash/isPlainObject';
import '../_common/js/tree/tree-node.js';
import '@babel/runtime/helpers/asyncToGenerator';
import '@babel/runtime/helpers/toConsumableArray';
import '@babel/runtime/regenerator';
import 'lodash/uniqueId';
import 'lodash/get';
import '../_common/js/tree/tree-node-model.js';
import 'lodash/pick';
import '../_common/js/log/log.js';
import '@babel/runtime/helpers/objectWithoutProperties';
import '@babel/runtime/helpers/slicedToArray';
import '@babel/runtime/helpers/typeof';
import '../utils/render-tnode.js';
import 'lodash/isString';
import 'lodash/isFunction';
import 'lodash/isObject';
import '../config-provider/config-receiver.js';
import '../config-provider/zh_CN_config.js';
import '../config-provider/type.js';
import '../utils/mixins.js';
import './utils/panel.js';
import 'lodash/isNumber';
import './components/Item.js';
import 'tdesign-icons-vue-next';
import '../utils/classnames.js';
import '../utils/ripple.js';
import '../utils/set-style.js';
import './utils/item.js';
import '../checkbox/index.js';
import '../checkbox/checkbox.js';
import '../checkbox/props.js';
import '../checkbox/group.js';
import 'lodash/intersection';
import '../checkbox/checkbox-group-props.js';
import '../utils/map-props.js';
import 'lodash/kebabCase';
import '../utils/withInstall.js';
import '../checkbox/style';
import '../checkbox/type.js';
import '../tooltip/index.js';
import '../tooltip/tooltip.js';
import '../tooltip/props.js';
import '../popup/props.js';
import '../tooltip/style';
import '../tooltip/type.js';
import '../popup/popup.js';
import '@popperjs/core';
import '../_chunks/dep-b66bfe36.js';
import '../utils/dom.js';
import '../utils/easing.js';
import '../popup/style';
import '../popup/type.js';
import '../loading/index.js';
import '../loading/loading.js';
import '../loading/icon/gradient.js';
import '../_common/js/loading/circle-adapter.js';
import '../_common/js/utils/set-style.js';
import '../_common/js/utils/helper.js';
import '../utils/transfer-dom.js';
import '../loading/props.js';
import '../loading/style';
import '../loading/type.js';
import '../loading/plugin.js';
import '../tag/index.js';
import '../tag/tag.js';
import '../tag/props.js';
import '../tag/check-tag.js';
import '../tag/check-tag-props.js';
import '../tag/style';
import '../tag/type.js';
import '../input/index.js';
import '../input/addon.js';
import '../input/input.js';
import '../input/props.js';
import '../input/input-group.js';
import '../input/style';
import '../input/type.js';
import '../common-components/fake-arrow.js';
import './utils/inputContent.js';
import './type.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var name = "".concat(prefix, "-cascader");
var _Cascader = defineComponent({
  name: "TCascader",
  components: {
    Popup: Popup,
    Panel: Panel,
    Transition: Transition,
    InputContent: InputContent
  },
  props: _objectSpread({}, props),
  emits: ["change", "remove", "blur", "focus"],
  data: function data() {
    return {
      inputWidth: 0,
      visible: false,
      treeStore: null,
      inputVal: "",
      scopeVal: this.defaultValue,
      treeNodes: [],
      filterActive: false,
      expend: []
    };
  },
  computed: {
    stateFns: function stateFns() {
      var _this = this;

      return {
        setTreeNodes: function setTreeNodes(nodes) {
          _this.treeNodes = nodes;
        },
        setValue: function setValue(val, source, node) {
          if (isEqual(val, _this.scopeVal)) return;
          emitEvent(_this, "change", val, {
            source: source,
            node: node
          });
        },
        setVisible: function setVisible(val) {
          _this.visible = val;
        },
        setFilterActive: function setFilterActive(val) {
          _this.filterActive = val;
        },
        setInputVal: function setInputVal(val) {
          _this.inputVal = val;
        },
        setExpend: function setExpend(val) {
          _this.expend = val;
        },
        setInputWidth: function setInputWidth(val) {
          _this.inputWidth = val;
        }
      };
    },
    cascaderContext: function cascaderContext() {
      var value = this.scopeVal;
      var _this$size = this.size,
          size = _this$size === void 0 ? "medium" : _this$size,
          _this$checkStrictly = this.checkStrictly,
          checkStrictly = _this$checkStrictly === void 0 ? false : _this$checkStrictly,
          _this$lazy = this.lazy,
          lazy = _this$lazy === void 0 ? true : _this$lazy,
          _this$multiple = this.multiple,
          multiple = _this$multiple === void 0 ? false : _this$multiple,
          _this$filterable = this.filterable,
          filterable = _this$filterable === void 0 ? false : _this$filterable,
          _this$clearable = this.clearable,
          clearable = _this$clearable === void 0 ? false : _this$clearable,
          _this$checkProps = this.checkProps,
          checkProps = _this$checkProps === void 0 ? {} : _this$checkProps,
          _this$max = this.max,
          max = _this$max === void 0 ? 0 : _this$max,
          disabled = this.disabled,
          _this$showAllLevels = this.showAllLevels,
          showAllLevels = _this$showAllLevels === void 0 ? true : _this$showAllLevels,
          _this$minCollapsedNum = this.minCollapsedNum,
          minCollapsedNum = _this$minCollapsedNum === void 0 ? 0 : _this$minCollapsedNum,
          loading = this.loading,
          _this$valueType = this.valueType,
          valueType = _this$valueType === void 0 ? "single" : _this$valueType;
      var visible = this.visible,
          treeStore = this.treeStore,
          treeNodes = this.treeNodes,
          filterActive = this.filterActive,
          inputVal = this.inputVal,
          inputWidth = this.inputWidth;
      return _objectSpread({
        valueType: valueType,
        loading: loading,
        size: size,
        disabled: disabled,
        checkStrictly: checkStrictly,
        lazy: lazy,
        multiple: multiple,
        filterable: filterable,
        checkProps: checkProps,
        clearable: clearable,
        showAllLevels: showAllLevels,
        max: max,
        value: value,
        visible: visible,
        treeStore: treeStore,
        treeNodes: treeNodes,
        filterActive: filterActive,
        inputVal: inputVal,
        inputWidth: inputWidth,
        minCollapsedNum: minCollapsedNum
      }, this.stateFns);
    }
  },
  watch: {
    value: {
      handler: function handler(val) {
        var valueType = this.valueType,
            multiple = this.multiple;
        if (isEqual(val, this.scopeVal)) return;
        this.scopeVal = getValue(val, valueType, multiple);
        this.updateExpend();
        this.updatedTreeNodes();
      }
    },
    inputVal: function inputVal() {
      var _this$cascaderContext = this.cascaderContext,
          value = _this$cascaderContext.value,
          setExpend = _this$cascaderContext.setExpend;

      if (!getTreeValue(value).length) {
        setExpend([]);
      }

      this.updatedTreeNodes();
    },
    filterActive: function filterActive() {
      var filterActive = this.cascaderContext.filterActive;

      if (!filterActive) {
        this.inputVal = "";
      }
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    var value = this.value,
        multiple = this.multiple,
        _this$cascaderContext2 = this.cascaderContext,
        setValue = _this$cascaderContext2.setValue,
        showAllLevels = _this$cascaderContext2.showAllLevels,
        valueType = this.valueType;

    if (multiple && !Array.isArray(value) || !multiple && Array.isArray(value) && !showAllLevels) {
      var val = multiple ? [] : "";
      setValue(val, "invalid-value");
      console.warn("TDesign Cascader Warn:", "cascader props value invalid, v-model automatic calibration");
    }

    if (!isEmpty(value)) {
      this.scopeVal = getValue(value, valueType, multiple);
    }

    this.init();
    ["checkStrictly", "disabled", "keys", "lazy", "load", "options", "valueMode"].forEach(function (key) {
      _this2.$watch(key, function () {
        _this2.init();
      });
    });
  },
  methods: {
    init: function init() {
      var _this3 = this;

      var disabled = this.disabled,
          keys = this.keys,
          _this$checkStrictly2 = this.checkStrictly,
          checkStrictly = _this$checkStrictly2 === void 0 ? false : _this$checkStrictly2,
          _this$lazy2 = this.lazy,
          lazy = _this$lazy2 === void 0 ? true : _this$lazy2,
          load = this.load,
          options = this.options,
          _this$valueMode = this.valueMode,
          valueMode = _this$valueMode === void 0 ? "onlyLeaf" : _this$valueMode;
      if (!options || Array.isArray(options) && !options.length) return;
      this.treeStore = new TreeStore({
        keys: keys || {},
        checkable: true,
        checkStrictly: checkStrictly,
        expandMutex: true,
        expandParent: true,
        disabled: disabled,
        load: load,
        lazy: lazy,
        valueMode: valueMode,
        onLoad: function onLoad() {
          setTimeout(function () {
            _this3.treeStore.refreshNodes();

            _this3.updatedTreeNodes();
          }, 0);
        }
      });
      this.treeStore.append(options);
      this.$nextTick(function () {
        _this3.updateExpend();

        _this3.updatedTreeNodes();
      });
    },
    updatedTreeNodes: function updatedTreeNodes() {
      var _this$cascaderContext3 = this.cascaderContext,
          inputVal = _this$cascaderContext3.inputVal,
          treeStore = _this$cascaderContext3.treeStore,
          setTreeNodes = _this$cascaderContext3.setTreeNodes;
      treeNodesEffect(inputVal, treeStore, setTreeNodes);
    },
    updateExpend: function updateExpend() {
      var _this$cascaderContext4 = this.cascaderContext,
          treeStore = _this$cascaderContext4.treeStore,
          value = _this$cascaderContext4.value,
          expend = this.expend;
      if (!treeStore) return;
      treeStoreExpendEffect(treeStore, value, expend);
      treeStore.replaceChecked(getTreeValue(value));
    }
  },
  render: function render() {
    var _this4 = this;

    var visible = this.visible,
        trigger = this.trigger,
        empty = this.empty,
        $attrs = this.$attrs,
        cascaderContext = this.cascaderContext,
        $slots = this.$slots,
        placeholder = this.placeholder,
        collapsedItems = this.collapsedItems;
    var popupProps = this.popupProps;
    var listeners = {};
    EVENT_NAME_WITH_KEBAB.forEach(function (eventName) {
      listeners[getPropsApiByEvent(eventName)] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        emitEvent.apply(void 0, [_this4, eventName].concat(args));
      };
    });
    return createVNode(Popup, mergeProps({
      "class": "".concat(name, "__popup"),
      "overlayClassName": "".concat(name, "__dropdown"),
      "placement": "bottom-left",
      "visible": visible,
      "expandAnimation": true,
      "trigger": (popupProps === null || popupProps === void 0 ? void 0 : popupProps.trigger) || "click"
    }, popupProps), {
      "default": function _default() {
        return [createVNode(InputContent, mergeProps($attrs, {
          "cascaderContext": cascaderContext,
          "placeholder": placeholder,
          "collapsedItems": collapsedItems,
          "listeners": listeners
        }), {
          collapsedItems: $slots.collapsedItems
        })];
      },
      content: function content() {
        return createVNode(resolveComponent("panel"), {
          "empty": empty,
          "trigger": trigger,
          "cascaderContext": cascaderContext
        }, {
          empty: $slots.empty
        });
      }
    });
  }
});

export { _Cascader as default };
//# sourceMappingURL=cascader.js.map
