/**
 * tdesign v0.8.0
 * (c) 2022 tdesign
 * @license MIT
 */

import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _typeof from '@babel/runtime/helpers/typeof';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { g as getDefaultExportFromCjs } from '../_chunks/dep-b66bfe36.js';
import isEmpty from 'lodash/isEmpty';
import isNumber from 'lodash/isNumber';
import { getCharacterLength } from '../utils/helper.js';
import '@babel/runtime/helpers/objectWithoutProperties';
import '@babel/runtime/helpers/slicedToArray';
import 'lodash/camelCase';

var isDate$1 = {exports: {}};

var merge$1 = {exports: {}};

(function (module, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = merge;

  function merge() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var defaults = arguments.length > 1 ? arguments[1] : undefined;

    for (var key in defaults) {
      if (typeof obj[key] === 'undefined') {
        obj[key] = defaults[key];
      }
    }

    return obj;
  }

  module.exports = exports["default"];
  module.exports["default"] = exports["default"];
})(merge$1, merge$1.exports);

var merge = /*@__PURE__*/getDefaultExportFromCjs(merge$1.exports);

(function (module, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = isDate;

  var _merge = _interopRequireDefault(merge$1.exports);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function F() {};

        return {
          s: F,
          n: function n() {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function e(_e2) {
            throw _e2;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function s() {
        it = o[Symbol.iterator]();
      },
      n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function e(_e3) {
        didErr = true;
        err = _e3;
      },
      f: function f() {
        try {
          if (!normalCompletion && it["return"] != null) it["return"]();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  var default_date_options = {
    format: 'YYYY/MM/DD',
    delimiters: ['/', '-'],
    strictMode: false
  };

  function isValidFormat(format) {
    return /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(format);
  }

  function zip(date, format) {
    var zippedArr = [],
        len = Math.min(date.length, format.length);

    for (var i = 0; i < len; i++) {
      zippedArr.push([date[i], format[i]]);
    }

    return zippedArr;
  }

  function isDate(input, options) {
    if (typeof options === 'string') {
      // Allow backward compatbility for old format isDate(input [, format])
      options = (0, _merge["default"])({
        format: options
      }, default_date_options);
    } else {
      options = (0, _merge["default"])(options, default_date_options);
    }

    if (typeof input === 'string' && isValidFormat(options.format)) {
      var formatDelimiter = options.delimiters.find(function (delimiter) {
        return options.format.indexOf(delimiter) !== -1;
      });
      var dateDelimiter = options.strictMode ? formatDelimiter : options.delimiters.find(function (delimiter) {
        return input.indexOf(delimiter) !== -1;
      });
      var dateAndFormat = zip(input.split(dateDelimiter), options.format.toLowerCase().split(formatDelimiter));
      var dateObj = {};

      var _iterator = _createForOfIteratorHelper(dateAndFormat),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
              dateWord = _step$value[0],
              formatWord = _step$value[1];

          if (dateWord.length !== formatWord.length) {
            return false;
          }

          dateObj[formatWord.charAt(0)] = dateWord;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return new Date("".concat(dateObj.m, "/").concat(dateObj.d, "/").concat(dateObj.y)).getDate() === +dateObj.d;
    }

    if (!options.strictMode) {
      return Object.prototype.toString.call(input) === '[object Date]' && isFinite(input);
    }

    return false;
  }

  module.exports = exports["default"];
  module.exports["default"] = exports["default"];
})(isDate$1, isDate$1.exports);

var isDate = /*@__PURE__*/getDefaultExportFromCjs(isDate$1.exports);

var isEmail$1 = {exports: {}};

var assertString$1 = {exports: {}};

(function (module, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = assertString;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function assertString(input) {
    var isString = typeof input === 'string' || input instanceof String;

    if (!isString) {
      var invalidType = _typeof(input);

      if (input === null) invalidType = 'null';else if (invalidType === 'object') invalidType = input.constructor.name;
      throw new TypeError("Expected a string but received a ".concat(invalidType));
    }
  }

  module.exports = exports["default"];
  module.exports["default"] = exports["default"];
})(assertString$1, assertString$1.exports);

var assertString = /*@__PURE__*/getDefaultExportFromCjs(assertString$1.exports);

var isByteLength$1 = {exports: {}};

(function (module, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = isByteLength;

  var _assertString = _interopRequireDefault(assertString$1.exports);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }
  /* eslint-disable prefer-rest-params */


  function isByteLength(str, options) {
    (0, _assertString["default"])(str);
    var min;
    var max;

    if (_typeof(options) === 'object') {
      min = options.min || 0;
      max = options.max;
    } else {
      // backwards compatibility: isByteLength(str, min [, max])
      min = arguments[1];
      max = arguments[2];
    }

    var len = encodeURI(str).split(/%..|./).length - 1;
    return len >= min && (typeof max === 'undefined' || len <= max);
  }

  module.exports = exports["default"];
  module.exports["default"] = exports["default"];
})(isByteLength$1, isByteLength$1.exports);

var isByteLength = /*@__PURE__*/getDefaultExportFromCjs(isByteLength$1.exports);

var isFQDN$1 = {exports: {}};

(function (module, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = isFQDN;

  var _assertString = _interopRequireDefault(assertString$1.exports);

  var _merge = _interopRequireDefault(merge$1.exports);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  var default_fqdn_options = {
    require_tld: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_numeric_tld: false,
    allow_wildcard: false
  };

  function isFQDN(str, options) {
    (0, _assertString["default"])(str);
    options = (0, _merge["default"])(options, default_fqdn_options);
    /* Remove the optional trailing dot before checking validity */

    if (options.allow_trailing_dot && str[str.length - 1] === '.') {
      str = str.substring(0, str.length - 1);
    }
    /* Remove the optional wildcard before checking validity */


    if (options.allow_wildcard === true && str.indexOf('*.') === 0) {
      str = str.substring(2);
    }

    var parts = str.split('.');
    var tld = parts[parts.length - 1];

    if (options.require_tld) {
      // disallow fqdns without tld
      if (parts.length < 2) {
        return false;
      }

      if (!/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
        return false;
      } // disallow spaces


      if (/\s/.test(tld)) {
        return false;
      }
    } // reject numeric TLDs


    if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
      return false;
    }

    return parts.every(function (part) {
      if (part.length > 63) {
        return false;
      }

      if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
        return false;
      } // disallow full-width chars


      if (/[\uff01-\uff5e]/.test(part)) {
        return false;
      } // disallow parts starting or ending with hyphen


      if (/^-|-$/.test(part)) {
        return false;
      }

      if (!options.allow_underscores && /_/.test(part)) {
        return false;
      }

      return true;
    });
  }

  module.exports = exports["default"];
  module.exports["default"] = exports["default"];
})(isFQDN$1, isFQDN$1.exports);

var isFQDN = /*@__PURE__*/getDefaultExportFromCjs(isFQDN$1.exports);

var isIP$1 = {exports: {}};

(function (module, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = isIP;

  var _assertString = _interopRequireDefault(assertString$1.exports);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  /**
  11.3.  Examples
  
     The following addresses
  
               fe80::1234 (on the 1st link of the node)
               ff02::5678 (on the 5th link of the node)
               ff08::9abc (on the 10th organization of the node)
  
     would be represented as follows:
  
               fe80::1234%1
               ff02::5678%5
               ff08::9abc%10
  
     (Here we assume a natural translation from a zone index to the
     <zone_id> part, where the Nth zone of any scope is translated into
     "N".)
  
     If we use interface names as <zone_id>, those addresses could also be
     represented as follows:
  
              fe80::1234%ne0
              ff02::5678%pvc1.3
              ff08::9abc%interface10
  
     where the interface "ne0" belongs to the 1st link, "pvc1.3" belongs
     to the 5th link, and "interface10" belongs to the 10th organization.
   * * */


  var IPv4SegmentFormat = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
  var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
  var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
  var IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';
  var IPv6AddressRegExp = new RegExp('^(' + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ')(%[0-9a-zA-Z-.:]{1,})?$');

  function isIP(str) {
    var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    (0, _assertString["default"])(str);
    version = String(version);

    if (!version) {
      return isIP(str, 4) || isIP(str, 6);
    }

    if (version === '4') {
      if (!IPv4AddressRegExp.test(str)) {
        return false;
      }

      var parts = str.split('.').sort(function (a, b) {
        return a - b;
      });
      return parts[3] <= 255;
    }

    if (version === '6') {
      return !!IPv6AddressRegExp.test(str);
    }

    return false;
  }

  module.exports = exports["default"];
  module.exports["default"] = exports["default"];
})(isIP$1, isIP$1.exports);

var isIP = /*@__PURE__*/getDefaultExportFromCjs(isIP$1.exports);

(function (module, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = isEmail;

  var _assertString = _interopRequireDefault(assertString$1.exports);

  var _merge = _interopRequireDefault(merge$1.exports);

  var _isByteLength = _interopRequireDefault(isByteLength$1.exports);

  var _isFQDN = _interopRequireDefault(isFQDN$1.exports);

  var _isIP = _interopRequireDefault(isIP$1.exports);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  var default_email_options = {
    allow_display_name: false,
    require_display_name: false,
    allow_utf8_local_part: true,
    require_tld: true,
    blacklisted_chars: '',
    ignore_max_length: false,
    host_blacklist: []
  };
  /* eslint-disable max-len */

  /* eslint-disable no-control-regex */

  var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
  var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
  var gmailUserPart = /^[a-z\d]+$/;
  var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
  var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
  var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
  var defaultMaxEmailLength = 254;
  /* eslint-enable max-len */

  /* eslint-enable no-control-regex */

  /**
   * Validate display name according to the RFC2822: https://tools.ietf.org/html/rfc2822#appendix-A.1.2
   * @param {String} display_name
   */

  function validateDisplayName(display_name) {
    var display_name_without_quotes = display_name.replace(/^"(.+)"$/, '$1'); // display name with only spaces is not valid

    if (!display_name_without_quotes.trim()) {
      return false;
    } // check whether display name contains illegal character


    var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);

    if (contains_illegal) {
      // if contains illegal characters,
      // must to be enclosed in double-quotes, otherwise it's not a valid display name
      if (display_name_without_quotes === display_name) {
        return false;
      } // the quotes in display name must start with character symbol \


      var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;

      if (!all_start_with_back_slash) {
        return false;
      }
    }

    return true;
  }

  function isEmail(str, options) {
    (0, _assertString["default"])(str);
    options = (0, _merge["default"])(options, default_email_options);

    if (options.require_display_name || options.allow_display_name) {
      var display_email = str.match(splitNameAddress);

      if (display_email) {
        var display_name = display_email[1]; // Remove display name and angle brackets to get email address
        // Can be done in the regex but will introduce a ReDOS (See  #1597 for more info)

        str = str.replace(display_name, '').replace(/(^<|>$)/g, ''); // sometimes need to trim the last space to get the display name
        // because there may be a space between display name and email address
        // eg. myname <address@gmail.com>
        // the display name is `myname` instead of `myname `, so need to trim the last space

        if (display_name.endsWith(' ')) {
          display_name = display_name.substr(0, display_name.length - 1);
        }

        if (!validateDisplayName(display_name)) {
          return false;
        }
      } else if (options.require_display_name) {
        return false;
      }
    }

    if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
      return false;
    }

    var parts = str.split('@');
    var domain = parts.pop();
    var lower_domain = domain.toLowerCase();

    if (options.host_blacklist.includes(lower_domain)) {
      return false;
    }

    var user = parts.join('@');

    if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
      /*
        Previously we removed dots for gmail addresses before validating.
        This was removed because it allows `multiple..dots@gmail.com`
        to be reported as valid, but it is not.
        Gmail only normalizes single dots, removing them from here is pointless,
        should be done in normalizeEmail
      */
      user = user.toLowerCase(); // Removing sub-address from username before gmail validation

      var username = user.split('+')[0]; // Dots are not included in gmail length restriction

      if (!(0, _isByteLength["default"])(username.replace(/\./g, ''), {
        min: 6,
        max: 30
      })) {
        return false;
      }

      var _user_parts = username.split('.');

      for (var i = 0; i < _user_parts.length; i++) {
        if (!gmailUserPart.test(_user_parts[i])) {
          return false;
        }
      }
    }

    if (options.ignore_max_length === false && (!(0, _isByteLength["default"])(user, {
      max: 64
    }) || !(0, _isByteLength["default"])(domain, {
      max: 254
    }))) {
      return false;
    }

    if (!(0, _isFQDN["default"])(domain, {
      require_tld: options.require_tld
    })) {
      if (!options.allow_ip_domain) {
        return false;
      }

      if (!(0, _isIP["default"])(domain)) {
        if (!domain.startsWith('[') || !domain.endsWith(']')) {
          return false;
        }

        var noBracketdomain = domain.substr(1, domain.length - 2);

        if (noBracketdomain.length === 0 || !(0, _isIP["default"])(noBracketdomain)) {
          return false;
        }
      }
    }

    if (user[0] === '"') {
      user = user.slice(1, user.length - 1);
      return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
    }

    var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
    var user_parts = user.split('.');

    for (var _i = 0; _i < user_parts.length; _i++) {
      if (!pattern.test(user_parts[_i])) {
        return false;
      }
    }

    if (options.blacklisted_chars) {
      if (user.search(new RegExp("[".concat(options.blacklisted_chars, "]+"), 'g')) !== -1) return false;
    }

    return true;
  }

  module.exports = exports["default"];
  module.exports["default"] = exports["default"];
})(isEmail$1, isEmail$1.exports);

var isEmail = /*@__PURE__*/getDefaultExportFromCjs(isEmail$1.exports);

var isURL$1 = {exports: {}};

(function (module, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = isURL;

  var _assertString = _interopRequireDefault(assertString$1.exports);

  var _isFQDN = _interopRequireDefault(isFQDN$1.exports);

  var _isIP = _interopRequireDefault(isIP$1.exports);

  var _merge = _interopRequireDefault(merge$1.exports);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  /*
  options for isURL method
  
  require_protocol - if set as true isURL will return false if protocol is not present in the URL
  require_valid_protocol - isURL will check if the URL's protocol is present in the protocols option
  protocols - valid protocols can be modified with this option
  require_host - if set as false isURL will not check if host is present in the URL
  require_port - if set as true isURL will check if port is present in the URL
  allow_protocol_relative_urls - if set as true protocol relative URLs will be allowed
  validate_length - if set as false isURL will skip string length validation (IE maximum is 2083)
  
  */


  var default_url_options = {
    protocols: ['http', 'https', 'ftp'],
    require_tld: true,
    require_protocol: false,
    require_host: true,
    require_port: false,
    require_valid_protocol: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_protocol_relative_urls: false,
    allow_fragments: true,
    allow_query_components: true,
    validate_length: true
  };
  var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

  function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
  }

  function checkHost(host, matches) {
    for (var i = 0; i < matches.length; i++) {
      var match = matches[i];

      if (host === match || isRegExp(match) && match.test(host)) {
        return true;
      }
    }

    return false;
  }

  function isURL(url, options) {
    (0, _assertString["default"])(url);

    if (!url || /[\s<>]/.test(url)) {
      return false;
    }

    if (url.indexOf('mailto:') === 0) {
      return false;
    }

    options = (0, _merge["default"])(options, default_url_options);

    if (options.validate_length && url.length >= 2083) {
      return false;
    }

    if (!options.allow_fragments && url.includes('#')) {
      return false;
    }

    if (!options.allow_query_components && (url.includes('?') || url.includes('&'))) {
      return false;
    }

    var protocol, auth, host, hostname, port, port_str, split, ipv6;
    split = url.split('#');
    url = split.shift();
    split = url.split('?');
    url = split.shift();
    split = url.split('://');

    if (split.length > 1) {
      protocol = split.shift().toLowerCase();

      if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
        return false;
      }
    } else if (options.require_protocol) {
      return false;
    } else if (url.substr(0, 2) === '//') {
      if (!options.allow_protocol_relative_urls) {
        return false;
      }

      split[0] = url.substr(2);
    }

    url = split.join('://');

    if (url === '') {
      return false;
    }

    split = url.split('/');
    url = split.shift();

    if (url === '' && !options.require_host) {
      return true;
    }

    split = url.split('@');

    if (split.length > 1) {
      if (options.disallow_auth) {
        return false;
      }

      if (split[0] === '') {
        return false;
      }

      auth = split.shift();

      if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
        return false;
      }

      var _auth$split = auth.split(':'),
          _auth$split2 = _slicedToArray(_auth$split, 2),
          user = _auth$split2[0],
          password = _auth$split2[1];

      if (user === '' && password === '') {
        return false;
      }
    }

    hostname = split.join('@');
    port_str = null;
    ipv6 = null;
    var ipv6_match = hostname.match(wrapped_ipv6);

    if (ipv6_match) {
      host = '';
      ipv6 = ipv6_match[1];
      port_str = ipv6_match[2] || null;
    } else {
      split = hostname.split(':');
      host = split.shift();

      if (split.length) {
        port_str = split.join(':');
      }
    }

    if (port_str !== null && port_str.length > 0) {
      port = parseInt(port_str, 10);

      if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
        return false;
      }
    } else if (options.require_port) {
      return false;
    }

    if (options.host_whitelist) {
      return checkHost(host, options.host_whitelist);
    }

    if (!(0, _isIP["default"])(host) && !(0, _isFQDN["default"])(host, options) && (!ipv6 || !(0, _isIP["default"])(ipv6, 6))) {
      return false;
    }

    host = host || ipv6;

    if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
      return false;
    }

    return true;
  }

  module.exports = exports["default"];
  module.exports["default"] = exports["default"];
})(isURL$1, isURL$1.exports);

var isURL = /*@__PURE__*/getDefaultExportFromCjs(isURL$1.exports);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function isValueEmpty(val) {
  var type = Object.prototype.toString.call(val);
  var typeMap = {
    Date: "[object Date]"
  };

  if (type === typeMap.Date) {
    return false;
  }

  return _typeof(val) === "object" ? isEmpty(val) : ["", void 0, null].includes(val);
}
var VALIDATE_MAP = {
  date: isDate,
  url: isURL,
  email: isEmail,
  required: function required(val) {
    return !isValueEmpty(val);
  },
  "boolean": function boolean(val) {
    return typeof val === "boolean";
  },
  max: function max(val, num) {
    return isNumber(val) ? val <= num : getCharacterLength(val) <= num;
  },
  min: function min(val, num) {
    return isNumber(val) ? val >= num : getCharacterLength(val) >= num;
  },
  len: function len(val, num) {
    return getCharacterLength(val) === num;
  },
  number: function number(val) {
    return !Number.isNaN(val);
  },
  "enum": function _enum(val, strs) {
    return strs.includes(val);
  },
  idcard: function idcard(val) {
    return /^(\d{18,18}|\d{15,15}|\d{17,17}x)$/i.test(val);
  },
  telnumber: function telnumber(val) {
    return /^1[3-9]\d{9}$/.test(val);
  },
  pattern: function pattern(val, regexp) {
    return regexp.test(val);
  },
  validator: function validator(val, validate2) {
    return validate2(val);
  }
};
function validateOneRule(_x, _x2) {
  return _validateOneRule.apply(this, arguments);
}

function _validateOneRule() {
  _validateOneRule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value, rule) {
    var validateResult, keys, vOptions, vValidateFun, i, key, validateRule;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            validateResult = {
              result: true
            };
            keys = Object.keys(rule);
            vOptions = {};
            i = 0;

          case 4:
            if (!(i < keys.length)) {
              _context.next = 16;
              break;
            }

            key = keys[i];

            if (!(!rule.required && isValueEmpty(value) && !rule.validator)) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return", validateResult);

          case 8:
            validateRule = VALIDATE_MAP[key];

            if (!(validateRule && rule[key])) {
              _context.next = 13;
              break;
            }

            vOptions = rule[key] === true ? {} : rule[key];
            vValidateFun = validateRule;
            return _context.abrupt("break", 16);

          case 13:
            i++;
            _context.next = 4;
            break;

          case 16:
            if (!vValidateFun) {
              _context.next = 24;
              break;
            }

            _context.next = 19;
            return vValidateFun(value, vOptions);

          case 19:
            validateResult = _context.sent;

            if (!(typeof validateResult === "boolean")) {
              _context.next = 22;
              break;
            }

            return _context.abrupt("return", _objectSpread(_objectSpread({}, rule), {}, {
              result: validateResult
            }));

          case 22:
            if (!(_typeof(validateResult) === "object")) {
              _context.next = 24;
              break;
            }

            return _context.abrupt("return", validateResult);

          case 24:
            return _context.abrupt("return", validateResult);

          case 25:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _validateOneRule.apply(this, arguments);
}

function validate(_x3, _x4) {
  return _validate.apply(this, arguments);
}

function _validate() {
  _validate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(value, rules) {
    var all, r;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            all = rules.map(function (rule) {
              return validateOneRule(value, rule);
            });
            _context2.next = 3;
            return Promise.all(all);

          case 3:
            r = _context2.sent;
            return _context2.abrupt("return", r);

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _validate.apply(this, arguments);
}

export { isValueEmpty, validate, validateOneRule };
//# sourceMappingURL=form-model.js.map
